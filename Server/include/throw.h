/* 106 228 203 199 203 251 69 164 171 249 223 147 102 233 72 137 119 94 82 90 79 10 155 183 241 217 150 77 172 108 93 173 68 19 40 212 204 206 54 180 157 223 26 99 125 119 19 97 77 110 19 247 97 96 131 5 72 145 14 214 105 62 226 154 70 6 217 121 223 90 234 52 213 76 97 23 184  */
#pragma once 

/* The _Noreturn keyword of draft C1X.  */
// iconv 소스에서 발췌.
// http://www.open-std.org/jtc1/sc22/wg14/www/docs/n1453.htm
#ifdef _MSC_VER
#  define _Noreturn __declspec (noreturn)
#else
#  define _Noreturn __attribute__ ((__noreturn__))
#endif


// #ifndef _Noreturn
// # if (3 <= __GNUC__ || (__GNUC__ == 2 && 8 <= __GNUC_MINOR__) \
// 	  || 0x5110 <= __SUNPRO_C)
// #  define _Noreturn __attribute__ ((__noreturn__))
// # elif 1200 <= _MSC_VER
// #  define _Noreturn __declspec (noreturn)
// # else
// #  define _Noreturn
// # endif
// #endif

#ifdef _MSC_VER
#define _Noinline __declspec(noinline)
#else
#define _Noinline __attribute__ ((noinline))
#endif

#ifdef _MSC_VER
#pragma pack(push,8)
#endif

namespace Proud
{
	/* C++ exception을 throw 하는 구문을 래핑한 함수들.
	
	Q: 왜 직접 throw를 안하고 함수로 래핑했나요?
	A: NDK, PS4, UE4 등 일부 상황에서는 throw keyword를 못 씁니다. 즉 exception handling을 금하는 컴파일러 설정을 씁니다.
	이러한 상황에서는 이렇게 함수로 래핑된 것을 쓸 수밖에 없습니다.
	한편, 그러한 곳에서는, 호출되는 함수X가 throw를 하면 안되지만, 호출되는 함수에서 호출하는 내부 함수들Y은 throw를 하더라도,
	X에서 catch를 해준다면, 문제 없습니다. 
	
	Q: exception.h에 있으면 될텐데요?
	A: exception.h는 pnstring.h를 include하는데, pnstring.h는 아래 함수들을 씁니다.
	*/
	_Noreturn void ThrowInvalidArgumentException();
	_Noreturn void ThrowArrayOutOfBoundException();
	_Noreturn void ThrowBadAllocException();
	_Noreturn void ThrowException(const char* text);
}
#ifdef _MSC_VER
#pragma pack(pop)
#endif